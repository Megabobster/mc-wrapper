#!/bin/bash

# triggers when the grab function is run
# variables available are "$grab", the argument passed to the grab function

if [ "$grab" = "blend" ] ; then
	player="$grabber"
	if echo "$last" | grep -q '^\[..:..:..\] \[Server thread/INFO\]: .* has .* that match the criteria$' ; then
		mc scoreboard players set "$player" blend 1
		mc execute "$player" "~ ~ ~" scoreboard players set @e[type=Item,c=1,r=3] blend 2
	elif echo "$last" | grep -q '^\[..:..:..\] \[Server thread/INFO\]: Could not clear the inventory of .*, no items to remove$' ; then
		mc tellraw "$player" [\"["$ARMORSTAND"] Blending costs 1 book\"]
	elif echo "$last" | grep -q '^\[..:..:..\] \[Server thread/INFO\]: The data tag did not change: {.*}$' ; then
		set_score_zero="blend"
		if echo "$last" | grep -q '^.*{ench:.*}$' ; then
			#repair_cost="$(echo \"$last\" | sed 's///')"
			mc kill "$item"
			mc clear "$player" minecraft:book -1 1
			mc xp -5L "$player" # todo make this based on RepairCost, maybe also increase RepairCost with blend, and check to make sure the player can afford it
			mc give "$player" minecraft:enchanted_book 1 0 "$(echo "$last" | sed 's/^.*{ench:/{StoredEnchantments:/;s/,Damage:0s.*$//')"
		else # not necessary if there's ever a NBT wildcard for dataTag selectors {Item:{tag:{ench:*}}}
			mc tellraw "$player" [\"["$ARMORSTAND"] Item not enchanted\"]
			mc scoreboard players reset "$item" blend
		fi
	else # make sure to put this else at the end of each grab
		mc say "$ERR_UNEXPECTED_GRAB_INPUT" "$grab".
	fi
#elif [ "$grab" = "xyz" ] ; then
#	if echo "$last" | grep -q '^\[..:..:..\] \[Server thread/INFO\]: \[-: Teleported Armor Stand to .*, .*, .*\]$' ; then
#		mc say beep
#		kill @e[type=ArmorStand,name=xyz,tag=xyz]
#	else
#		mc say "$ERR_UNEXPECTED_GRAB_INPUT" "$grab".
#	fi
elif [ "$grab" = "smash" ] ; then
	player="$grabber"
	set_score_zero="smash"
	mc say boop
else # make sure to leave this here
	mc say "$ERR_INVALID_GRAB" "$grab".
fi
